/*
 * mini-cp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License  v3
 * as published by the Free Software Foundation.
 *
 * mini-cp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY.
 * See the GNU Lesser General Public License  for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with mini-cp. If not, see http://www.gnu.org/licenses/lgpl-3.0.en.html
 *
 * Copyright (c)  2018. by Laurent Michel, Pierre Schaus, Pascal Van Hentenryck
 */

package minicp.search;

import minicp.state.StateManager;
import minicp.util.exception.InconsistencyException;
import minicp.util.exception.NotImplementedException;
import minicp.util.Procedure;

import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.Deque;
import java.util.ArrayDeque;

/**
 * Depth First Search Branch and Bound implementation
 */
public class DFSearch {

    private Supplier<Procedure[]> branching;
    private StateManager sm;


    private List<DFSListener> dfsListeners = new LinkedList<DFSListener>();


    private int currNodeIdId;

    /**
     * Creates a Depth First Search object with a given branching
     * that defines the search tree dynamically.
     *
     * @param sm the state manager that will be saved and restored
     *           at each node of the search tree
     * @param branching a generator of closures in charge of defining the ordered
     *                  children nodes at each node of the depth-first-search tree.
     *                  When it returns an empty array, a solution is found.
     *                  A backtrack occurs when a {@link InconsistencyException}
     *                  is thrown.
     */
    public DFSearch(StateManager sm, Supplier<Procedure[]> branching) {
        this.sm = sm;
        this.branching = branching;
    }

    /**
     * Adds a listener that is called on each solution.
     *
     * @param listener the closure to be called whenever a solution is found
     */
    public void onSolution(Procedure listener) {
        dfsListeners.add(new DFSListener() {
            @Override
            public void solution(int pId, int id, int position) {
                listener.call();
            }
        });
    }


    public void addListener(DFSListener listener) {
        dfsListeners.add(listener);
    }

    /**
     * Adds a listener that is called whenever a failure occurs
     * and the search backtracks.
     * This happensthat when a {@link InconsistencyException} is thrown
     * when executing the closure generated by the branching.
     *
     * @param listener the closure to be called whenever a failure occurs and
     *                 the search need to backtrack
     */
    public void onFailure(Procedure listener) {
        dfsListeners.add(new DFSListener() {
            @Override
            public void fail(int pId, int id, int position) {
                listener.call();
            }
        });
    }


    private void notifySolution(int parentId, int nodeId, int position) {
        dfsListeners.forEach(l -> l.solution(parentId, nodeId, position));
    }

    private void notifyFailure(int parentId, int nodeId, int position) {
        dfsListeners.forEach(l -> l.fail(parentId, nodeId, position));
    }

    private void notifyBranch(int parentId, int nodeId, int position, int nChilds) {
        dfsListeners.forEach(l -> l.branch(parentId, nodeId, position, nChilds));
    }

    private SearchStatistics solve(SearchStatistics statistics, Predicate<SearchStatistics> limit) {
        currNodeIdId = 0;
        sm.withNewState(() -> {
            try {
                dfs(statistics, limit , -1, -1);
                statistics.setCompleted();
            } catch (StopSearchException ignored) {
            } catch (StackOverflowError e) {
                throw new NotImplementedException("dfs with explicit stack needed to pass this test");
            }
        });
        return statistics;
    }


    /**
     * Effectively start a depth first search
     * looking for every solution.
     *
     * @return an object with the statistics on the search
     */
    public SearchStatistics solve() {
        SearchStatistics statistics = new SearchStatistics();
        return solve(statistics, stats -> false);
    }

    /**
     * Effectively start a depth first search
     * with a given predicate called at each node
     * to stop the search when it becomes true.
     *
     * @param limit a predicate called at each node
     *             that stops the search when it becomes true
     * @return an object with the statistics on the search
     */
    public SearchStatistics solve(Predicate<SearchStatistics> limit) {
        SearchStatistics statistics = new SearchStatistics();
        return solve(statistics, limit);
    }

    /**
     * Executes a closure prior to effectively
     * starting a depth first search
     * with a given predicate called at each node
     * to stop the search when it becomes true.
     * The state manager saves the state
     * before executing the closure
     * and restores it after the search.
     * Any {@link InconsistencyException} that may
     * be throw when executing the closure is also catched.
     *
     * @param limit a predicate called at each node
     *             that stops the search when it becomes true
     * @param subjectTo the closure to execute prior to the search starts
     * @return an object with the statistics on the search
     */
    public SearchStatistics solveSubjectTo(Predicate<SearchStatistics> limit, Procedure subjectTo) {
        SearchStatistics statistics = new SearchStatistics();
        sm.withNewState(() -> {
            try {
                subjectTo.call();
                solve(statistics, limit);
            } catch (InconsistencyException e) {
            }
        });
        return statistics;
    }

    /**
     * Effectively start a branch and bound
     * depth first search with a given objective.
     *
     * @param obj the objective to optimize that is tightened each
     *            time a new solution is found
     * @return an object with the statistics on the search
     */
    public SearchStatistics optimize(Objective obj) {
        return optimize(obj, stats -> false);
    }

    /**
     * Effectively start a branch and bound
     * depth first search with a given objective
     * and with a given predicate called at each node
     * to stop the search when it becomes true.
     *
     * @param obj the objective to optimize that is tightened each
     *            time a new solution is found
     * @param limit a predicate called at each node
     *             that stops the search when it becomes true
     * @return an object with the statistics on the search
     */
    public SearchStatistics optimize(Objective obj, Predicate<SearchStatistics> limit) {
        SearchStatistics statistics = new SearchStatistics();
        onSolution(() -> obj.tighten());
        return solve(statistics, limit);
    }

    /**
     * Executes a closure prior to effectively
     * starting a branch and bound depth first search
     * with a given objective to optimize
     * and a given predicate called at each node
     * to stop the search when it becomes true.
     * The state manager saves the state
     * before executing the closure
     * and restores it after the search.
     * Any {@link InconsistencyException} that may
     * be throw when executing the closure is also catched.
     *
     * @param obj the objective to optimize that is tightened each
     *            time a new solution is found
     * @param limit a predicate called at each node
     *             that stops the search when it becomes true
     * @param subjectTo the closure to execute prior to the search starts
     * @return an object with the statistics on the search
     */
    public SearchStatistics optimizeSubjectTo(Objective obj, Predicate<SearchStatistics> limit, Procedure subjectTo) {
        AtomicReference<SearchStatistics> statistics = new AtomicReference<>();
        statistics.set(new SearchStatistics());
        sm.withNewState(() -> {
            try {
                subjectTo.call();
                statistics.set(optimize(obj, limit));
            } catch (InconsistencyException e) {
            }
        });
        return statistics.get();
    }

    private static class Frame {
        int parentId;
        int position;
        int nodeId;
        Procedure[] branches = null;
        int next = 0;
        boolean restore = false;
    }

    private void dfs(SearchStatistics statistics, Predicate<SearchStatistics> limit, int parentId, int position) {
        Deque<Frame> stack = new ArrayDeque<>();
        Frame root = new Frame();
        root.parentId = parentId;
        root.position = position;
        stack.push(root);

        while (!stack.isEmpty()) {
            if (limit.test(statistics)) {
                while (!stack.isEmpty()) {
                    Frame f = stack.pop();
                    if (f.restore) sm.restoreState();
                }
                throw new StopSearchException();
            }

            Frame f = stack.peek();

            if (f.branches == null) {
                f.branches = branching.get();
                f.nodeId = currNodeIdId++;
                if (f.branches.length == 0) {
                    statistics.incrSolutions();
                    notifySolution(f.parentId, f.nodeId, f.position);
                    stack.pop();
                    if (f.restore) sm.restoreState();
                    continue;
                } else {
                    notifyBranch(f.parentId, f.nodeId, f.position, f.branches.length);
                    f.next = 0;
                    continue;
                }
            }

            if (f.next >= f.branches.length) {
                stack.pop();
                if (f.restore) sm.restoreState();
                continue;
            }

            int p = f.next++;
            Procedure b = f.branches[p];
            sm.saveState();
            try {
                statistics.incrNodes();
                b.call();
                Frame child = new Frame();
                child.parentId = f.nodeId;
                child.position = p;
                child.restore = true;
                stack.push(child);
            } catch (InconsistencyException e) {
                currNodeIdId++;
                statistics.incrFailures();
                notifyFailure(f.parentId, f.nodeId, p);
                sm.restoreState();
            }
        }
    }

}
